name=mongo-sink-filtered-domains
connector.class=com.mongodb.kafka.connect.MongoSinkConnector
topics=filtered_input_domains

connection.uri=mongodb://connect:XudtfxKsnpDHvk3LXW6eiuJfLSAZTz6t@mongo:27017/admin
server.api.version=1
database=domainradar
collection=filtered_domains

key.converter=org.apache.kafka.connect.storage.StringConverter
# The Postgres source escapes the JSON string so we can't send it to MongoDB directly
# The JSON converter can handle it (at the cost of de-/serialization)
value.converter=org.apache.kafka.connect.json.JsonConverter
value.converter.schemas.enable=false

transforms=HoistKey,InsertTimestamp
transforms.HoistKey.type=org.apache.kafka.connect.transforms.HoistField$Key
transforms.HoistKey.field=domainName
transforms.InsertTimestamp.type=org.apache.kafka.connect.transforms.InsertField$Key
transforms.InsertTimestamp.timestamp.field=timestamp

max.batch.size=5
bulk.write.ordered=false
tasks.max=1

# Add the _id field using the FullKey strategy (the { domainName, timestamp } document will be used as _id)
post.processor.chain=com.mongodb.kafka.connect.sink.processor.DocumentIdAdder
document.id.strategy=com.mongodb.kafka.connect.sink.processor.id.strategy.FullKeyStrategy

# Although the IDs should be unique, this supports at-least-once delivery
writemodel.strategy=com.mongodb.kafka.connect.sink.writemodel.strategy.ReplaceOneDefaultStrategy
